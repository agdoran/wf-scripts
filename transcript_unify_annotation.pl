#!/usr/bin/perl -w
use strict;
use Getopt::Long;

my $tsv = ""; # input TSV file
my $gtf = ""; # input GTF file
my $output; # output TSV formatted file
my $help;

########################################################
# USAGE
#
my $USAGE =<<USAGE;

This is a short script to merge information contained the output directories from wf-transcriptomes:
https://github.com/epi2me-labs/wf-transcriptomes

This is a personal script in no way associated with Oxford Nanopore or the wf-transcriptomes workflow and
may not be appropriate for all versions of the workflow. 

While every effort is made to ensure this script is bug free, this should not be assumed to be true and 
users should confirm or validate the results of this script themselves before. 

Usage:

	perl $0 --tsv <str_merged.tracking tsv file> --gtf <str_merged.annotated.gtf> --output <new output TSV file> [--help]

	where:

		tsv:    This is the str_merge TSV file for each of the isoform classes. e.g. str_merged.tracking.u.tsv
		gtf:    This is the GTF formatted annotation file for the isforms
		output: The file to write the results to
		help:   Prints out this helpful message

	Notes on inputs:
		TSV: 	Example row (5 comma separated columns): TCONS_id,query_locus_id,ref_gene_id,class,details
				details column is | separated containing 7 columns: internalID:qry_gene_id|qry_id|num_exons|FPKM|TPM|cov|len
		GTF:	Only features of the type transcript (3rd column) will be retained. Exon features are excluded
		OUTPUT:	Example output row (tab separated)
				chr start end feature Assembly_tool strand qry_id class_code qry_gene_name qry_gene_id query_locus_id tscons_id qry_gene_id qry_id exon_number FPKM TPM average_coverage transcript_length

	Notes on behaviour:
		Any transcript in the TSV which is not found in the GTF will not be output
		If a transcript identifiers in the TSV file are assumed unique. If an identifier is found twice, you will get an error
		The number of columns in the TSV file is assumed fixed. If there are not 5 comma separated columns, outputs may be incorrect
		The fifth column in each TSV row is assumed to contain 7 pipe (|) separated columns. If there are not 7 pipe separated columns, outputs may be incorrect
		Header row in the first line is assumed (and the first row is always skipped)

		Any transcript in the GTF which is not found in the TSV will be skipped
		If a unique transcript ID is found more than once for a transcript feature, you will get an error (and have a problematic GTF)
		No header is present in the GTF generated by the wf-transcriptomes workflow, and this is assumed for your input

USAGE
#
######################################################

# parse parameters
GetOptions ("tsv|i=s" => \$tsv,    # input file
            "gtf|g=s"   => \$gtf,      # annotation file
            "output|o=s"  => \$output,   # output file
            "help|h"  => \$help)   # help
or die("Error in command line arguments. See help page --help\n");


# checks on inputs for correctness
if ($help) {
    print "$USAGE\n";
    exit 0;

}elsif(! -f "$tsv" || ! -f "$gtf"){
    print "Error with your option selection or inputs, please see help page\n\n";
    exit 1;

}

if(not defined $output){
	print "No output specified, please see help page\n\n";
    exit 1;

}

# print some general indication of status 
print "All parameters confirmed. Starting merging of information from $tsv with coordinate information for the transcript features in $gtf\n";
print "Reading the TSV file\n";



# open and parse the TSV file 
open(TSV, "$tsv") or die "Error opening input TSV file\n"; # read

my %idcols; # we will store the IDs as keys in this hash. The value of the hash key will be the line from the input TSV
my %idcode; # the GFF class code will be stored for the ID and used to confirm present only once in input

while(my $line = <TSV>){
	chomp $line;

	# skip the header row
	next if ($. == 1);

	# the TSV rows are comma separated with 5 columns in every row. If your file has more or less columns, this will likely break the script and an error will be printed 
	my @tsvcols = split(",", $line);
	if(@tsvcols != 5){
		print "Error with the number of columns in your input TSV file\n";
		exit 1;

	}

	my ($tscons_id,$query_locus_id,$ref_gene_id,$class,$details) = split(",", $line);

	# in the TSV, for classes overlapping a gene name, you will have gene_name|gene_id
	# this if statement will check this and modify ref_gene_name and ref_gene_id to only contain the correct value 
	my $ref_gene_name = $ref_gene_id;
	if($ref_gene_id =~ m/\|/){
		$ref_gene_name =~ s/\|.*//;
		$ref_gene_id =~ s/^.*\|//;

	}

	# the last column contains attributes split by a pipe: | 
	# we need to extract the second column which contains the unique transcript ID which matches the transcript_id attribute in the GTF file
	# this is the GFF compare qry_id
	my @attscols = split(/\|/, $tsvcols[-1]);

	# there should always be 7 columns
	if(@attscols != 7){
		print "Error with the number of columns in your input TSV file at line $.\n";
		exit 1;

	}

	my ($gene,$transcript,$exons,$fpkm,$tpm,$cov,$len) = split(/\|/, $tsvcols[-1]);
	# transcript is a unique ID across all files and corresponds to the qry_id

	# remove leading qID from gene number - not used in any other file. This will now be the same as qry_gene_id
	$gene =~ s/^.*\://;

	# capture the information to match to the GTF information
	$idcols{$transcript} = "$transcript\t$class\t$ref_gene_name\t$ref_gene_id\t$query_locus_id\t$tscons_id\t$gene\t$transcript\t$exons\t$fpkm\t$tpm\t$cov\t$len";
	# columns: qry_id class_code qry_gene_name qry_gene_id query_locus_id tscons_id qry_gene_id qry_id exon_number FPKM TPM average_coverage transcript_length

	# confirm unique ID only appears once
	if(exists $idcode{$transcript}){
		print "Error - unique ID found more than once at $.\n";
		exit 1;

	}

	$idcode{$transcript} = "$class";

}

close(TSV);


# print some general indication of status 
print "Finished reading the TSV file. Now reading the GTF file\n";
print "transcripts found in both files will be printed to the output file as they are found\n";
print "We will also print matching transcripts to the output file\n";


# open and parse the GTF file
open(GTF, "$gtf") or die "Error opening GTF file\n"; # read
open(OUT, ">$output") or die "Error opening your output file\n"; # write

# print a header line for the file - begin header with leading #
print OUT "#chr\tstart\tend\tfeature\tAssembly_tool\tstrand\tqry_id\tclass_code\tqry_gene_name\tqry_gene_id\tquery_locus_id\ttscons_id\tqry_gene_id\tqry_id\texon_number\tFPKM\tTPM\taverage_coverage\ttranscript_length\n";

my %uniquecheck;

while(my $line = <GTF>){
	chomp $line;
	next if($line =~ m/^#/);

	my @array = split("\t", $line);
	my $atts = $array[8];

	# skip feature rows which are not transcripts
	next unless($array[2] eq "transcript");

	# additional check to confirm that transcript_id is contained. This is a requirement of GTF format but don't conform to this specification
	# this will also ignore GFF annotations which do not have a transcript_id attribute
	next unless($atts =~ m/transcript_id/);

	my $ti = $atts;
	$ti =~ s/^.*transcript_id \"//;
	$ti =~ s/\".*$//; 

	if(exists $uniquecheck{$ti}){
		print "Error - GTF unique ID found more than once at \n"; # may need to confirm the ID is unique for all contexts - may only u classes
		exit 1;

	}else{
		$uniquecheck{$ti} = 1;

	}

	next unless ($idcols{$ti}); # confirm value in the TSV file or skip it

	# now print information merged from both files but only retaining the GTF coordinates
	print OUT "$array[0]\t$array[3]\t$array[4]\t$array[2]\t$array[1]\t$array[6]\t$idcols{$ti}\n";
	# output columns: chr start end feature Assembly_tool strand qry_id class_code qry_gene_name qry_gene_id query_locus_id tscons_id qry_gene_id qry_id exon_number FPKM TPM average_coverage transcript_length

}

close(GTF);
close(OUT);

print "Finished all reading and writing of outputs\n";

